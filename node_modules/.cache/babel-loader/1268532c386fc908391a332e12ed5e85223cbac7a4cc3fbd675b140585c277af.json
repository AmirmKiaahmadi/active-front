{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let {\n      cacheName,\n      plugins = [],\n      fallbackToNetwork = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    });\n    // Bind the install and activate methods to the instance.\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n  precache(entries) {\n    this.addToCacheList(entries);\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n    const urlsToWarnAbout = [];\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n      this._urlsToCacheModes.set(url, cacheMode);\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = \"Workbox is precaching URLs without revision \" + \"info: \".concat(urlsToWarnAbout.join(', '), \"\\nThis is generally NOT safe. \") + \"Learn more at https://bit.ly/wb-precache\";\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.InstallResult>}\n   */\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const installReportPlugin = new PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin);\n      // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n        const cacheMode = this._urlsToCacheModes.get(url);\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n      if (process.env.NODE_ENV !== 'production') {\n        printInstallDetails(updatedURLs, notUpdatedURLs);\n      }\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.CleanupResult>}\n   */\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        printCleanupDetails(deletedURLs);\n      }\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {workbox-routing~handlerCallback}\n   */\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n}\nexport { PrecacheController };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}