{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n  /**\n   * @param {Object} [options]\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n   * that fail to respond within the timeout will result in a network error.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: this.constructor.name,\n        funcName: '_handle',\n        paramName: 'request'\n      });\n    }\n    let error = undefined;\n    let response;\n    try {\n      const promises = [handler.fetch(request)];\n      if (this._networkTimeoutSeconds) {\n        const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n        promises.push(timeoutPromise);\n      }\n      response = await Promise.race(promises);\n      if (!response) {\n        throw new Error(\"Timed out the network response after \" + \"\".concat(this._networkTimeoutSeconds, \" seconds.\"));\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        error = err;\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n      if (response) {\n        logger.log(\"Got response from network.\");\n      } else {\n        logger.log(\"Unable to get a response from the network.\");\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n    if (!response) {\n      throw new WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n    return response;\n  }\n}\nexport { NetworkOnly };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}