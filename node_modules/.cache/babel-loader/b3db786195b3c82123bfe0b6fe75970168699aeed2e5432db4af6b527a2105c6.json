{"ast":null,"code":"// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(window.location.hostname === 'localhost' ||\n// [::1] is the IPv6 localhost address.\nwindow.location.hostname === '[::1]' ||\n// 127.0.0.0/8 are considered localhost for IPv4.\nwindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n    window.addEventListener('install', function (e) {\n      //@ts-ignore\n      e.waitUntil(Promise.all([\n      //@ts-expect-error\n      caches.open(STATIC_CACHE_NAME),\n      //@ts-expect-error\n      caches.open(APP_CACHE_NAME),\n      //@ts-expect-error\n      window.skipWaiting()]).then(function (storage) {\n        const static_cache = storage[0];\n        const app_cache = storage[1];\n        return Promise.all([\n        //@ts-expect-error\n        static_cache.addAll(CACHE_STATIC),\n        //@ts-expect-error\n        app_cache.addAll(CACHE_APP)]);\n      }));\n    });\n    window.addEventListener('activate', function (e) {\n      //@ts-ignore\n      e.waitUntil(Promise.all([\n      //@ts-expect-error\n      window.clients.claim(), caches.keys().then(function (cacheNames) {\n        return Promise.all(cacheNames.map(function (cacheName) {\n          if (\n          //@ts-expect-error\n          cacheName !== APP_CACHE_NAME &&\n          //@ts-expect-error\n          cacheName !== STATIC_CACHE_NAME) {\n            return caches.delete(cacheName);\n          }\n        }));\n      })]));\n    });\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.ts`;\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(registration => {\n          // Use the PushManager to get the user's subscription to the push service.\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker.register(swUrl).then(registration => {\n    registration.pushManager.getSubscription().then(async function (subscription) {\n      // If a subscription was found, return it.\n      // if (subscription) {\n      //   console.log(subscription);\n      //   return subscription;\n      // }\n      // return registration.pushManager.subscribe({\n      //   userVisibleOnly: true,\n      //   applicationServerKey: urlBase64ToUint8Array(\n      //     'BO60T_oiPYcjRST9Dkppg-R69kEoLjSZliLw0EvTwAof6IdU8v-7c4ROpG16LPG0fsoGH7k_gvXGBjnyxvEov2c',\n      //   ),\n      // });\n      // Get the server's public key\n      //const response = await fetch('./vapidPublicKey');\n      //const vapidPublicKey = await response.text();\n      //const vapidKeys = webpush.generateVAPIDKeys();\n      // Chrome doesn't accept the base64-encoded (string) vapidPublicKey yet\n      // urlBase64ToUint8Array() is defined in /tools.js\n      //const convertedVapidKey = vapidKeys;\n      // webpush.setVapidDetails(\n      //   'https://shop.beta.mazraeapp.com/',\n      //   vapidKeys.publicKey,\n      //   vapidKeys.privateKey,\n      // );\n      // Otherwise, subscribe the user (userVisibleOnly allows to specify that we don't plan to\n      // send notifications that don't have a visible effect for the user).\n    });\n    // .then(subscription => {\n    //   console.log('info workers');\n    //   console.log(subscription);\n    //   try {\n    //     const userProfile = window.localStorage.getItem('user');\n    //     fetch(\n    //       process.env.REACT_APP_API_URL + '/api/profile/supplier/set-fcm',\n    //       {\n    //         method: 'PATCH',\n    //         headers: {\n    //           'Content-type': 'application/json',\n    //           Authorization: userProfile\n    //             ? `Token ${JSON.parse(userProfile)?.token}`\n    //             : '',\n    //         },\n    //         body: JSON.stringify({\n    //           fcm_token: subscription,\n    //         }),\n    //       },\n    //     );\n    //   } catch (error) {\n    //     console.log(error);\n    //   }\n    // });\n\n    registration.update();\n    setInterval(() => {\n      registration.update();\n    }, 1000 * 60 * 5);\n    registration.onupdatefound = () => {\n      const installingWorker = registration.installing;\n      if (installingWorker == null) {\n        return;\n      }\n      installingWorker.onstatechange = () => {\n        if (installingWorker.state === 'installed') {\n          if (navigator.serviceWorker.controller) {\n            // At this point, the updated precached content has been fetched,\n            // but the previous service worker will still serve the older\n            // content until all client tabs are closed.\n            // console.log('update find...');\n\n            //  ShowToastMessage({\n            //    type: 'Success',\n            //    text: 'در حال به روزرسانی...',\n            //  });\n            setTimeout(() => {\n              window.location.reload();\n            }, 2000);\n            //@ts-expect-error\n            registration.waiting.postMessage({\n              type: 'SKIP_WAITING'\n            });\n            //\n            // Execute callback\n            if (config && config.onUpdate) {\n              config.onUpdate(registration);\n            }\n          } else {\n            // console.log('display');\n            // At this point, everything has been precached.\n            // It's the perfect time to display a\n            // \"Content is cached for offline use.\" message.\n            // console.log('Content is cached for offline use.');\n\n            // Execute callback\n            if (config && config.onSuccess) {\n              config.onSuccess(registration);\n            }\n          }\n        }\n      };\n    };\n  }).catch(error => {});\n}\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {\n      'Service-Worker': 'script'\n    }\n  }).then(response => {\n    // Ensure service worker exists, and that we really are getting a JS file.\n    const contentType = response.headers.get('content-type');\n    if (response.status === 404 || contentType != null && contentType.indexOf('javascript') === -1) {\n      // No service worker found. Probably a different app. Reload the page.\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister().then(() => {\n          window.location.reload();\n        });\n      });\n    } else {\n      // Service worker found. Proceed as normal.\n      registerValidSW(swUrl, config);\n    }\n  }).catch(() => {});\n}\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    }).catch(error => {});\n  }\n}\n// function urlBase64ToUint8Array(base64String: string) {\n//   const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n//   const base64 = (base64String + padding)\n//     .replace(/\\-/g, '+')\n//     .replace(/_/g, '/');\n\n//   const rawData = window.atob(base64);\n//   const outputArray = new Uint8Array(rawData.length);\n\n//   for (let i = 0; i < rawData.length; ++i) {\n//     outputArray[i] = rawData.charCodeAt(i);\n//   }\n//   return outputArray;\n// }","map":{"version":3,"names":["isLocalhost","Boolean","window","location","hostname","match","register","config","process","env","NODE_ENV","navigator","publicUrl","URL","PUBLIC_URL","href","origin","addEventListener","e","waitUntil","Promise","all","caches","open","STATIC_CACHE_NAME","APP_CACHE_NAME","skipWaiting","then","storage","static_cache","app_cache","addAll","CACHE_STATIC","CACHE_APP","clients","claim","keys","cacheNames","map","cacheName","delete","swUrl","checkValidServiceWorker","serviceWorker","ready","registration","registerValidSW","pushManager","getSubscription","subscription","update","setInterval","onupdatefound","installingWorker","installing","onstatechange","state","controller","setTimeout","reload","waiting","postMessage","type","onUpdate","onSuccess","catch","error","fetch","headers","response","contentType","get","status","indexOf","unregister"],"sources":["/Users/amirkia/Documents/active-front/src/serviceWorkerRegistration.ts"],"sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.0/8 are considered localhost for IPv4.\n\t\twindow.location.hostname.match(\n\t\t\t/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n\t\t)\n);\n\ntype Config = {\n\tonSuccess?: (registration: ServiceWorkerRegistration) => void;\n\tonUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('install', function (e) {\n\t\t\t//@ts-ignore\n\t\t\te.waitUntil(\n\t\t\t\tPromise.all([\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tcaches.open(STATIC_CACHE_NAME),\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tcaches.open(APP_CACHE_NAME),\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\twindow.skipWaiting(),\n\t\t\t\t]).then(function (storage) {\n\t\t\t\t\tconst static_cache = storage[0];\n\t\t\t\t\tconst app_cache = storage[1];\n\t\t\t\t\treturn Promise.all([\n\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\tstatic_cache.addAll(CACHE_STATIC),\n\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\tapp_cache.addAll(CACHE_APP),\n\t\t\t\t\t]);\n\t\t\t\t})\n\t\t\t);\n\t\t});\n\n\t\twindow.addEventListener('activate', function (e) {\n\t\t\t//@ts-ignore\n\t\t\te.waitUntil(\n\t\t\t\tPromise.all([\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\twindow.clients.claim(),\n\t\t\t\t\tcaches.keys().then(function (cacheNames) {\n\t\t\t\t\t\treturn Promise.all(\n\t\t\t\t\t\t\tcacheNames.map(function (cacheName) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\t\t\tcacheName !== APP_CACHE_NAME &&\n\t\t\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\t\t\tcacheName !== STATIC_CACHE_NAME\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn caches.delete(cacheName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t])\n\t\t\t);\n\t\t});\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.ts`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\t// Use the PushManager to get the user's subscription to the push service.\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.pushManager\n\t\t\t\t.getSubscription()\n\t\t\t\t.then(async function (subscription) {\n\t\t\t\t\t// If a subscription was found, return it.\n\t\t\t\t\t// if (subscription) {\n\t\t\t\t\t//   console.log(subscription);\n\t\t\t\t\t//   return subscription;\n\t\t\t\t\t// }\n\t\t\t\t\t// return registration.pushManager.subscribe({\n\t\t\t\t\t//   userVisibleOnly: true,\n\t\t\t\t\t//   applicationServerKey: urlBase64ToUint8Array(\n\t\t\t\t\t//     'BO60T_oiPYcjRST9Dkppg-R69kEoLjSZliLw0EvTwAof6IdU8v-7c4ROpG16LPG0fsoGH7k_gvXGBjnyxvEov2c',\n\t\t\t\t\t//   ),\n\t\t\t\t\t// });\n\t\t\t\t\t// Get the server's public key\n\t\t\t\t\t//const response = await fetch('./vapidPublicKey');\n\t\t\t\t\t//const vapidPublicKey = await response.text();\n\t\t\t\t\t//const vapidKeys = webpush.generateVAPIDKeys();\n\t\t\t\t\t// Chrome doesn't accept the base64-encoded (string) vapidPublicKey yet\n\t\t\t\t\t// urlBase64ToUint8Array() is defined in /tools.js\n\t\t\t\t\t//const convertedVapidKey = vapidKeys;\n\t\t\t\t\t// webpush.setVapidDetails(\n\t\t\t\t\t//   'https://shop.beta.mazraeapp.com/',\n\t\t\t\t\t//   vapidKeys.publicKey,\n\t\t\t\t\t//   vapidKeys.privateKey,\n\t\t\t\t\t// );\n\t\t\t\t\t// Otherwise, subscribe the user (userVisibleOnly allows to specify that we don't plan to\n\t\t\t\t\t// send notifications that don't have a visible effect for the user).\n\t\t\t\t});\n\t\t\t// .then(subscription => {\n\t\t\t//   console.log('info workers');\n\t\t\t//   console.log(subscription);\n\t\t\t//   try {\n\t\t\t//     const userProfile = window.localStorage.getItem('user');\n\t\t\t//     fetch(\n\t\t\t//       process.env.REACT_APP_API_URL + '/api/profile/supplier/set-fcm',\n\t\t\t//       {\n\t\t\t//         method: 'PATCH',\n\t\t\t//         headers: {\n\t\t\t//           'Content-type': 'application/json',\n\t\t\t//           Authorization: userProfile\n\t\t\t//             ? `Token ${JSON.parse(userProfile)?.token}`\n\t\t\t//             : '',\n\t\t\t//         },\n\t\t\t//         body: JSON.stringify({\n\t\t\t//           fcm_token: subscription,\n\t\t\t//         }),\n\t\t\t//       },\n\t\t\t//     );\n\t\t\t//   } catch (error) {\n\t\t\t//     console.log(error);\n\t\t\t//   }\n\t\t\t// });\n\n\t\t\tregistration.update();\n\t\t\tsetInterval(\n\t\t\t\t() => {\n\t\t\t\t\tregistration.update();\n\t\t\t\t},\n\t\t\t\t1000 * 60 * 5\n\t\t\t);\n\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\t// console.log('update find...');\n\n\t\t\t\t\t\t\t//  ShowToastMessage({\n\t\t\t\t\t\t\t//    type: 'Success',\n\t\t\t\t\t\t\t//    text: 'در حال به روزرسانی...',\n\t\t\t\t\t\t\t//  });\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t\t}, 2000);\n\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\tregistration.waiting.postMessage({\n\t\t\t\t\t\t\t\ttype: 'SKIP_WAITING',\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.log('display');\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\t// console.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {});\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl, {\n\t\theaders: { 'Service-Worker': 'script' },\n\t})\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\t(contentType != null && contentType.indexOf('javascript') === -1)\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready\n\t\t\t.then((registration) => {\n\t\t\t\tregistration.unregister();\n\t\t\t})\n\t\t\t.catch((error) => {});\n\t}\n}\n// function urlBase64ToUint8Array(base64String: string) {\n//   const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n//   const base64 = (base64String + padding)\n//     .replace(/\\-/g, '+')\n//     .replace(/_/g, '/');\n\n//   const rawData = window.atob(base64);\n//   const outputArray = new Uint8Array(rawData.length);\n\n//   for (let i = 0; i < rawData.length; ++i) {\n//     outputArray[i] = rawData.charCodeAt(i);\n//   }\n//   return outputArray;\n// }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}